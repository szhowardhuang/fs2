    配备记忆体给二维阵列跟宣告的方式可以如下:

	mixed	a;
	a = allocate(10);
	a[0] = allocate(10);
	a[1] = allocate(10);
	...等等...
 
    如果这样宣告, 你可以把二维阵列想成阵列的阵列,
  也就是一维阵列的每个元素又是一个阵列, 因此可以如下的方式使用:
 
	i = a[0][0]		//  <-- 第 0 维阵列的第 0 个元素.
 
    就算是使用 * 宣告, 你也无法直接宣告超过一维的阵列, 如:
	int	*a;
    但是你却可以像上面的方式, 而拥有并使用超过一维的阵列,
  也就是透过 mixed 的方式, 让编译器不检查资料型态而达到目的.
 
    底下是另外一种宣告并使用二维阵列的例子:
 
	mixed a;
	a = ({ ({ 1, 2, 3 }), ({ 4, 5, 6 }) });
 
    以上面的例子来说, a[0] 会是 ({ 1, 2, 3 }), 而 a[0][2] 则是 3.
 
    底下也是一个合法的使用方式:
 
	mixed a;  
	a = ({ 0, 0, 0, 0 });  // 这样只是让阵列大小为 4
	a[0] = ({ 1, 2, 3 });  // 改变 a[0] 从 0 变成 ({ 1, 2, 3 })
	a[1] = ({ 1, 2, 3 });  // 改变 a[1] 从 0 变成 ({ 1, 2, 3 })
	...等等...
 
作者:
  John Price a.k.a. Raistlin
  wade 翻译
